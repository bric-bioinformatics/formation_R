---
title: "Handle the information"
author: "Elodie Darbo / Cyril Dourthe"
date: "`r Sys.Date()`"
output: html_document
---
<style>
details > summary {
  padding: 4px;
  width: 400px;
  background-color: #eeeeee;
  border: none;
  box-shadow: 1px 1px 2px #bbbbbb;
  cursor: pointer;
}
​
details > p {
  background-color: #E0F8EC;
  padding: 4px;
  margin: 0;
  box-shadow: 1px 1px 2px #bbbbbb;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

In many cases, the information you want to exploit is not contained in a single, perfectly readable dataset. It's important to be able to gather the information we have to optimize our operations.
R offers a range of functions for carrying out operations within a single dataframe or between several dataframes.

# *merge* function

The first function you can use is merge. This function is a standard feature of R and does not require you to download anything else.

```{r help merge}
help(merge)
#or
?merge
```

As always, if you're not familiar with a function, or if you're not sure how to use it, look it up with the help of R, or search directly on the Internet using the right keywords (and in English).

You can see that *merge* has many arguments. For our example, we only need 3 arguments :

* "x" : it will take the first dataframe
* "y" : it will take the second dataframe
* "by" : this argument is used to specify the column from which the dataframes are to be assembled.

This third argument is really important. This also means that to use the merge function on our two dataframes, there must be a column in common between the two. We can also have several columns in common.

------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------

*Example* :

For our example, we will take two dataframes with the following structure:

* df_1

```{r view df_1}
df_1
```
<details>
  <summary>df_1 structure</summary>

```
  id   name month_salary
1  1 Andrew         1560
2  2  Susan         1263
3  3   John         1576
4  4    Joe         1502
5  5   Jack         1684
6  6  Jacob         1774
7  7   Mary         1715
8  8   Kate         1564
```
</details>

------------------------------------------------------------------------------------------------------------------------------------------------------------

* df_2

```{r view df_2}
df_2
```
<details>
  <summary>df_2 structure</summary>

```
  id       name age       position
1  1     Andrew  59            CTO
2  2      Susan  59            CFO
3  3       John  54 Administrative
4  4        Joe  50     Technician
5  6      Jacob  62     Technician
6  7       Mary  53     Technician
7  8       Kate  58     Technician
8  9 Jacqueline  39     Technician
9 10        Ivy  61     Technician
```
</details>
\
Looking at these two dataframes, the first thing we notice is that there are two common columns, “id” and “name”. Then each dataframe has its own columns.\
The second observation we can make is that there are not the same number of lines between the two dataframes. We will merge our dataframes by "id" and "name". Let's see what happens.

------------------------------------------------------------------------------------------------------------------------------------------------------------

```{r merge df_1 df_2}
df_3 <- merge(df_1, df_2, by = c("id","name"))
```
<details>
  <summary>df_3 structure</summary>

```
  id   name month_salary age       position
1  1 Andrew         1560  59            CTO
2  2  Susan         1263  59            CFO
3  3   John         1576  54 Administrative
4  4    Joe         1502  50     Technician
5  6  Jacob         1774  62     Technician
6  7   Mary         1715  53     Technician
7  8   Kate         1564  58     Technician
```
</details>
\
We have created a new variable called “df_3” which contains the result of the merge of the two dataframes “df_1” and “df_2”. What's most striking is the number of lines in this new dataframe. There are 7 lines, compared with 8 in df_1 and 10 in df_2.
This is because the merge only takes into account common elements between each dataframe.

In df_1, we have a line with an id/name combination that is 5/Jack. This combination does not exist in df_2. This line is then ignored by the *merge* function.
Why doesn't merge take different lines into account?

Remember, when searching for function help, there are many other arguments than the ones we've used, including an argument called "all".
This argument allows you to specify whether you wish to keep all rows that is not common. By default, this argument is set to FALSE, so that only rows with data from both x and y are included in the output. So we need, to keep all rows, to set the argument to TRUE.

```{r merge df_1 df_2 v2}
df_4 <- merge(df_1, df_2, by = c("id","name"), all = TRUE)
```
<details>
  <summary>df_4 structure</summary>

```
   id       name month_salary age       position
1   1     Andrew         1560  59            CTO
2   2      Susan         1263  59            CFO
3   3       John         1576  54 Administrative
4   4        Joe         1502  50     Technician
5   5       Jack         1684  NA           <NA>
6   6      Jacob         1774  62     Technician
7   7       Mary         1715  53     Technician
8   8       Kate         1564  58     Technician
9   9 Jacqueline           NA  39     Technician
10 10        Ivy           NA  61     Technician
```
</details>
\
Now we have all the rows of the two dataframes df_1 and df_2. To compensate for the fact that some rows are not common and therefore lack information, NAs (Not Available) have been introduced.

# *dplyr* package

*dplyr* is a powerful package for data manipulation. It provides set of functions that can help to simplify complex data operations.

For the following examples, we will take a built-in dataset in R.
The dataset is named "storms" and it is contained in the *dplyr* package.

```{r storms dataset}
storms <- storms
storms
```
<details>
  <summary>storms dataset structure</summary>

```
# A tibble: 19,537 × 13
   name   year month   day  hour   lat  long status              category  wind pressure tropicalstorm_force_diameter hurricane_force_diameter
   <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>                  <dbl> <int>    <int>                        <int>                    <int>
 1 Amy    1975     6    27     0  27.5 -79   tropical depression       NA    25     1013                           NA                       NA
 2 Amy    1975     6    27     6  28.5 -79   tropical depression       NA    25     1013                           NA                       NA
 3 Amy    1975     6    27    12  29.5 -79   tropical depression       NA    25     1013                           NA                       NA
 4 Amy    1975     6    27    18  30.5 -79   tropical depression       NA    25     1013                           NA                       NA
 5 Amy    1975     6    28     0  31.5 -78.8 tropical depression       NA    25     1012                           NA                       NA
 6 Amy    1975     6    28     6  32.4 -78.7 tropical depression       NA    25     1012                           NA                       NA
 7 Amy    1975     6    28    12  33.3 -78   tropical depression       NA    25     1011                           NA                       NA
 8 Amy    1975     6    28    18  34   -77   tropical depression       NA    30     1006                           NA                       NA
 9 Amy    1975     6    29     0  34.4 -75.8 tropical storm            NA    35     1004                           NA                       NA
10 Amy    1975     6    29     6  34   -74.8 tropical storm            NA    40     1002                           NA                       NA
# ℹ 19,527 more rows
# ℹ Use `print(n = ...)` to see more rows
```
</details>

Unlike our first example, you can see in the Environment panel that this dataset contains almost 20,000 rows. This doesn't change the functions we'll be using; on the contrary, you'll see that you'll be able to work on very large datasets more easily.

With *dplyr* we can :

* Subset : We can select specific portions of data, such as rows, columns, or both, from a larger data set based on certain conditions. Subsetting allows to extract meaningful data for analysis without modifying the original data set. We can subset rows or columns or both.

![](figures_merging/subset.svg)
* Reshape : We can change the layout of a dataset. It means, for example, transform columns into rows or the invert. This is a common task in data analysis, particularly when you need to organize data in a structure that is best suited for your analysis. In R, this often involves transforming data between long (tidy) and wide formats.
In a wide format, each row represent a single observation, and columns represent variables (like in our df_1 or df_2 examples).
In a long format, each row is a single measurement, with a separate column for the variable and the value. This structure will be useful later for certain graphical representations.

![](figures_merging/reshape.svg)
* Modify : We can add new columns or modify existing columns in a dataframe. It allows to create new variables based on existing ones or to change the values in existing columns.

![](figures_merging/mutate.svg)

IMPORTANT : Before diving into the details of the package and its possibilities, you need to know there's a special way of using the functions in this package. We will take a look at a new symbol called pipe operator : "%>%". This symbol is used to link several operations (functions) to achieve the desired result.

```{r pipe example}
your_dataset %>% 
  function1(...) %>%
  function2(...)
```

Here the functions correspond tot he function available in *dplyr* package.
Let's take a look at some of the most important functions.


## *filter* function

The first function we will see is the *filter* function. This function allows you to extract the row(s) you are interested in based on a condition in column(s).

```{r filter help}
?dplyr::filter
```

Example : Extract every storm that occurred in 2000

```{r filter example}
storms %>% 
  filter(year == 2000)
```
<details>
  <summary>filter by year 2000</summary>

```
# A tibble: 449 × 13
   name      year month   day  hour   lat  long status              category  wind pressure tropicalstorm_force_diameter hurricane_force_diameter
   <chr>    <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>                  <dbl> <int>    <int>                        <int>                    <int>
 1 AL012000  2000     6     7    18  21   -93   tropical depression       NA    25     1008                           NA                       NA
 2 AL012000  2000     6     8     0  20.9 -92.8 tropical depression       NA    25     1009                           NA                       NA
 3 AL012000  2000     6     8     6  20.7 -93.1 tropical depression       NA    25     1010                           NA                       NA
 4 AL012000  2000     6     8    12  20.8 -93.5 tropical depression       NA    25     1010                           NA                       NA
 5 AL022000  2000     6    23     0   9.5 -19.8 tropical depression       NA    25     1010                           NA                       NA
 6 AL022000  2000     6    23     6   9.6 -21   tropical depression       NA    30     1009                           NA                       NA
 7 AL022000  2000     6    23    12   9.9 -22.6 tropical depression       NA    30     1009                           NA                       NA
 8 AL022000  2000     6    23    18  10.2 -24.5 tropical depression       NA    30     1009                           NA                       NA
 9 AL022000  2000     6    24     0  10.1 -26.2 tropical depression       NA    30     1009                           NA                       NA
10 AL022000  2000     6    24     6   9.9 -27.8 tropical depression       NA    30     1009                           NA                       NA
# ℹ 439 more rows
# ℹ Use `print(n = ...)` to see more rows
```
</details>

To filter by year, we refer to the year column and set that we want the year 2000 with the equality operator “==”.

## *select* function

The function *select* allows to extract the columns(s).

```{r select help}
?dplyr::select
```

Example : Extract name of storms and their status

```{r select example}
storms %>% 
  select(name, status)
```
<details>
  <summary>select name and status</summary>

```
# A tibble: 19,537 × 2
   name  status             
   <chr> <fct>              
 1 Amy   tropical depression
 2 Amy   tropical depression
 3 Amy   tropical depression
 4 Amy   tropical depression
 5 Amy   tropical depression
 6 Amy   tropical depression
 7 Amy   tropical depression
 8 Amy   tropical depression
 9 Amy   tropical storm     
10 Amy   tropical storm     
# ℹ 19,527 more rows
# ℹ Use `print(n = ...)` to see more rows
```
</details>

## *gather* function

*gather* function enables to gather columns into rows.

```{r gather help}
?dplyr::gather
```


## *spread* function

*spread* function do the invert of *gather* and enables to spread rows into columns

```{r spread help}
?dplyr::spread
```
